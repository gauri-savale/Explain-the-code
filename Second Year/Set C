Q1. 0/1 Knapsack (DAA)
Task: Maximize value for given weight limit using DP.
Code:
def knapsack(wt,val,W):
    n=len(wt)
    dp=[[0]*(W+1) for _ in range(n+1)]
    for i in range(1,n+1):
        for w in range(W+1):
            if wt[i-1]<=w: dp[i][w]=max(val[i-1]+dp[i-1][w-wt[i-1]],dp[i-1][w])
            else: dp[i][w]=dp[i-1][w]
    return dp[n][W]
wt=[1,3,4]; val=[15,20,30]; W=4
print(knapsack(wt,val,W))


Q2. Floyd-Warshall Algorithm (DAA)
Task: Find all-pairs shortest paths.
Code:
def floydWarshall(dist):
    V=len(dist)
    for k in range(V):
        for i in range(V):
            for j in range(V):
                if dist[i][k]+dist[k][j]<dist[i][j]:
                    dist[i][j]=dist[i][k]+dist[k][j]
    return dist
dist=[[0,3,float('inf'),7],[8,0,2,float('inf')],[5,float('inf'),0,1],[2,float('inf'),float('inf'),0]]
res=floydWarshall(dist)
for row in res: print(row)



Q3. BFS Traversal (DSA)
Task: Level-wise traversal of graph.
Code:
from collections import deque
def BFS(graph,start):
    visited=set([start])
    q=deque([start])
    while q:
        node=q.popleft()
        print(node,end=" ")
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                q.append(neighbor)
graph={0:[1,2],1:[2],2:[0,3],3:[3]}
BFS(graph,2)

